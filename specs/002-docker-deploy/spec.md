# Feature Specification: Деплой приложения

**Feature Branch**: `002-docker-deploy`
**Created**: 2026-02-25
**Status**: Draft
**Input**: User description: "Сделай деплой с помощью github actions, docker, секреты из GitHub"

## User Scenarios & Testing *(mandatory)*

### User Story 1 — Контейнеризация приложения (Priority: P1)

Приложение (Django backend + собранный React frontend + Telegram bot) упаковано в контейнер. Контейнер содержит все необходимое для запуска: зависимости, собранный фронтенд, статические файлы. База данных (SQLite) монтируется как volume для сохранения данных между перезапусками.

**Why this priority**: Контейнер — фундамент для любого деплоя. Без него автоматизация невозможна.

**Independent Test**: Собрать контейнер локально, запустить его с переменными окружения, убедиться что Django admin, API и Mini App работают, бот отвечает на /start.

**Acceptance Scenarios**:

1. **Given** контейнер собран, **When** он запускается с переменными окружения, **Then** Django сервер стартует, API отвечает, фронтенд отдается
2. **Given** контейнер перезапущен, **When** пользователь открывает приложение, **Then** данные из базы сохранены (volume)
3. **Given** контейнер запущен, **When** бот получает /start, **Then** бот отвечает кнопкой с Mini App

---

### User Story 2 — Автоматический деплой при пуше в main (Priority: P1)

Разработчик пушит изменения в ветку `main`. Система автоматически собирает контейнер, прогоняет тесты и деплоит новую версию на сервер. Секреты (токен бота, секретный ключ и т.д.) берутся из GitHub Secrets, а не хранятся в коде.

**Why this priority**: Основная ценность фичи — обновлять приложение без SSH на сервер.

**Independent Test**: Сделать коммит в main → убедиться, что пайплайн запускается, тесты проходят, новый контейнер разворачивается на сервере, приложение доступно.

**Acceptance Scenarios**:

1. **Given** код запушен в main, **When** пайплайн запускается, **Then** тесты проходят, образ собирается, доставляется и запускается на сервере
2. **Given** в GitHub Secrets настроены переменные окружения, **When** контейнер запускается, **Then** приложение использует эти переменные и работает корректно
3. **Given** тесты падают, **When** CI обнаруживает ошибку, **Then** деплой не происходит, разработчик получает уведомление

---

### User Story 3 — Ручной запуск деплоя (Priority: P3)

Разработчик может вручную запустить деплой конкретной ветки через интерфейс GitHub Actions (workflow_dispatch), не дожидаясь мержа в main.

**Why this priority**: Полезно для тестирования на сервере, но не критично для основного флоу.

**Independent Test**: Зайти в GitHub Actions → Run workflow → выбрать ветку → убедиться что деплой произошел.

**Acceptance Scenarios**:

1. **Given** разработчик на странице Actions, **When** он запускает workflow вручную, **Then** деплой выбранной ветки происходит на сервер

---

### Edge Cases

- Что происходит, если сервер недоступен во время деплоя? Пайплайн завершается с ошибкой, предыдущая версия продолжает работать.
- Что происходит при одновременном запуске двух деплоев? Используется группа конкурентности — второй ждет или отменяет первый.
- Что если секреты не настроены в GitHub? Пайплайн падает с понятным сообщением.
- Что если миграции базы данных содержат ошибку? Контейнер не стартует, предыдущая версия продолжает работать.

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: Система MUST собирать контейнер, содержащий backend, собранный frontend и bot-хэндлеры
- **FR-002**: Контейнер MUST принимать конфигурацию через переменные окружения (секреты не хранятся в образе)
- **FR-003**: Система MUST сохранять базу данных между перезапусками контейнера (persistent volume)
- **FR-004**: Система MUST выполнять миграции базы данных при каждом запуске контейнера
- **FR-005**: Система MUST собирать статические файлы при сборке контейнера
- **FR-006**: Система MUST автоматически запускать пайплайн при пуше в ветку `main`
- **FR-007**: Пайплайн MUST прогонять backend-тесты перед деплоем
- **FR-008**: Пайплайн MUST блокировать деплой, если тесты не проходят
- **FR-009**: Система MUST поддерживать ручной запуск деплоя через интерфейс CI
- **FR-010**: Система MUST использовать группу конкурентности для предотвращения параллельных деплоев

### Key Entities

- **Container Image**: Собранный образ приложения со всеми зависимостями, фронтендом и статикой
- **Secrets**: Переменные окружения (TELEGRAM_BOT_TOKEN, SECRET_KEY, TELEGRAM_WEBAPP_URL, ALLOWED_HOSTS), передаваемые в контейнер при деплое
- **Persistent Volume**: Хранилище для SQLite базы данных, монтируемое в контейнер

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: Полный цикл от пуша в main до работающего обновления на сервере занимает менее 10 минут
- **SC-002**: При падении тестов деплой не происходит в 100% случаев
- **SC-003**: После перезапуска контейнера все данные из базы сохраняются
- **SC-004**: Разработчик может запустить деплой без доступа к серверу по SSH — только через интерфейс CI

## Assumptions

- Целевой сервер — одна Linux-машина (VPS), доступная по SSH
- Приложение работает на одном сервере (не кластер)
- Используется SQLite — достаточно для текущих масштабов
- Фронтенд собирается внутри контейнера на этапе build
- Для запуска бота и веб-сервера используется один контейнер (процессы управляются внутри)
- Реестр контейнеров — GitHub Container Registry (ghcr.io)
